# ARCHITECTURE.md

This document explains the internal architecture of the **RSS Feed Aggregator**, including its major components, data flow, execution model, and how the CLI, database, and RSS subsystems interact.

The project follows a clean, modular structure built using standard Go practices, PostgreSQL, and SQLC for type-safe database access.

---

# üß± High-Level Architecture

The project is composed of four major subsystems:

1. **CLI Layer (`internal/cli/`)** ‚Äì parses commands, dispatches handlers, enforces login middleware.
2. **Database Layer (`internal/database/`)** ‚Äì SQLC-generated package for type-safe DB queries.
3. **Config Layer (`internal/config/`)** ‚Äì manages persistent app-level configuration.
4. **RSS Layer (`internal/rss/`)** ‚Äì fetches, parses, and stores RSS feed content.

A long-running background process (the *aggregator*) periodically fetches feeds and stores posts in PostgreSQL.

---

# üìÇ Project Directory Structure

```
internal/
  cli/
    cli_errors.go
    commands.go
    middleware.go
    state.go
    handlers/
      handler_addfeed.go
      handler_agg.go
      handler_browse.go
      handler_feeds.go
      handler_follow.go
      handler_following.go
      handler_help.go
      handler_login.go
      handler_register.go
      handler_reset.go
      handler_unfollow.go
      handler_users.go
  config/
    json_structure_config.go
  database/
    db.go
    feed_follows.sql.go
    feeds.sql.go
    posts.sql.go
    users_feeds_join.sql.go
    users.sql.go
  rss/
    fetch_feed.go
    rss_feed.go
    rss_item.go
    scrape_feeds.go
sql/
  queries/
    feed_follows.sql
    feeds.sql
    posts.sql
    users_feeds_join.sql
    users.sql
  schema/
    001_users.sql
    002_feeds.sql
    003_feed_follows.sql
    004_add_last_fetched_feeds.sql
    005_posts.sql
main.go
```

---

# üß† Execution Flow (How the Program Runs)

### 1. **Start the CLI Program**

The entry point `main.go`:

* loads configuration from `~/.rssfeedconfig.json`
* connects to PostgreSQL
* builds a global `State` (DB + config)
* registers all CLI commands into a command registry
* parses user input from `os.Args`
* dispatches to the appropriate handler via `Commands.Run()`

This provides an extendable CLI interface.

---

# üß© CLI Layer

Located in `internal/cli/`.

## ## Command Registry (`commands.go`)

Commands are mapped from string names to handler functions:

```go
map[string]func(*State, Command) error
```

This enables clean command handling.

### Workflow:

1. Parse command name and args.
2. Look up command handler in registry.
3. Execute handler.
4. Return errors up to `main.go`.

---

## ## Middleware (`middleware.go`)

Some commands require a logged-in user (e.g., `follow`, `unfollow`, `browse`).

`MiddlewareLoggedIn()` wraps handlers and:

* reads `CurrentUserName` from config
* checks that the user exists in the database
* injects the user into the handler

This mirrors authentication middleware in web frameworks.

---

## ## Handlers (`handlers/*.go`)

Each command has a dedicated handler, following this signature:

```go
func(s *State, cmd Command) error
```

Or for protected commands:

```go
func(s *State, cmd Command, user database.User) error
```

Responsibilities of handlers:

* validate CLI arguments
* perform DB or RSS operations
* update config
* format terminal output

Examples:

* `HandlerRegister` ‚Äì creates a new user
* `HandlerAddFeed` ‚Äì inserts feed + auto-follows it
* `HandlerAgg` ‚Äì starts the scrapeloop
* `HandlerBrowse` ‚Äì prints recent posts

Handlers do not perform any 'business' logic directly.

---

# üóÑÔ∏è Database Layer (SQLC)

Located in `internal/database/`.

This layer is generated by **sqlc**, based on SQL in `sql/queries/`.

### Benefits:

* Compile-time checked SQL
* Struct-based query parameters
* Automatic scan into Go data structures
* Eliminates string-based queries in handlers

### Major Tables:

* `users` ‚Äì system users
* `feeds` ‚Äì RSS feeds
* `feed_follows` ‚Äì join table (user ‚Üî feed)
* `posts` ‚Äì individual blog/news posts

Examples of sqlc-generated methods:

```go
GetUser(ctx, name)
CreateUser(ctx, params)
CreateFeed(ctx, params)
FollowFeed(ctx, params)
GetNextFeedToFetch(ctx)
CreatePost(ctx, params)
```

This keeps the handler layer extremely clean.

---

# üìÑ Config Layer

Stored in `internal/config/`.

### Purpose:

* Persist application settings across runs
* Store the currently logged-in user
* Store DB connection string

The file `~/.rssfeedconfig.json` holds:

```json
{
  "db_url": "postgres://...",
  "current_user_name": "rahul"
}
```

`SetUser()` updates this file when logging in or registering.

---

# üì° RSS Layer

Located in `internal/rss/`.

Responsible for:

* HTTP GET requests to fetch RSS XML
* Parsing XML into Go structs (`rss_feed.go`, `rss_item.go`)
* Extracting Title, Link, Description, PubDate
* Calling `CreatePost` to store posts

## ## Fetching Feeds (`fetch_feed.go`)

Uses Go's HTTP and XML packages:

```go
req, err := http.NewRequestWithContext(ctx, "GET", feedURL, nil)
req.Header.Set("User-Agent", "Feed-Aggregator")
client := &http.Client{}
resp, err := client.Do(req)

xml.Unmarshal(body, &rssStruct)
```

---

## ## Scraping Logic (`scrape_feeds.go`)

This is the heart of the aggregator.

Flow:

1. Select the next feed to fetch using `GetNextFeedToFetch()`.
2. Update its `last_fetched_at` timestamp with `MarkFeedFetched()`.
3. Download RSS XML via `FetchFeed()`.
4. Loop over all `<item>` entries.
5. Insert posts into DB.
6. Skip duplicates using Postgres unique constraints.

---

# üîÅ Aggregator Loop

Triggered by:

```sh
go run . agg 30s
```

Implemented in the handler:

```go
ticker := time.NewTicker(duration)
for ; ; <-ticker.C {
    rss.ScrapeFeeds(state)
}
```

### Behavior:

* Runs immediately once
* Then runs after every tick (e.g., every 30 seconds)
* Continues indefinitely until killed

This simulates a lightweight background worker.

---

# üñ•Ô∏è Data Flow Summary

```
CLI command ‚Üí commands.Run() ‚Üí middleware (optional) ‚Üí handler
                    ‚Üì
                database/sqlc
                    ‚Üì
                PostgreSQL
                    ‚Üì
                aggregator
                    ‚Üì
                rss.FetchFeed
                    ‚Üì
                rss.ScrapeFeeds
                    ‚Üì
                posts table
                    ‚Üì
                browse
```

Each layer performs a single responsibility, keeping the architecture clean and maintainable.

---

# üß© Key Design Decisions

* **SQLC** for type safety and zero runtime SQL errors.
* **Middleware** for login enforcement.
* **Ticker-based worker** rather than goroutines per feed (simpler, predictable).
* **Feed rotation** using `GetNextFeedToFetch` ensures fair, consistent polling.
* **Config file** avoids global variables and makes behavior persistent.
* **Separation of CLI vs business logic** keeps handlers small.

---

# ‚úîÔ∏è Conclusion

This architecture provides a maintainable, modular backend application written in Go. It demonstrates knowledge of:

* CLI design patterns
* database schema design
* SQLC and PostgreSQL
* XML parsing and RSS ingestion
* background workers and tickers
* multi-layer application structure

The project is fully extensible and ready for additional features such as concurrency, HTTP APIs, caching, or Docker deployment.
